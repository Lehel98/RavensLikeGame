void IsoRenderer::DrawMap(const std::vector<std::vector<int>>& mapData)
{
    const int rows = (int)mapData.size();
    const int cols = (int)mapData[0].size();

    // pálya középre igazítása (változatlanul)
    float mapW = cols * (tileWidth * 0.5f);
    float mapH = rows * (tileVisibleHeight * 0.5f);
    glm::vec2 offset(
        Globals::WindowWidth * 0.5f - mapW * 0.5f,
        Globals::WindowHeight * 0.5f - mapH * 0.5f
    );

    shader.Use();
    shader.SetMat4("projection", projection);
    shader.SetMat4("view", view);
    shader.SetInt("textureAtlas", 0);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glBindVertexArray(vao);

    // DIAGONÁLIS sorrend: s = x+y növekvő
    for (int s = 0; s <= rows + cols - 2; ++s) {
        int y0 = std::max(0, s - (cols - 1));
        int y1 = std::min(rows - 1, s);
        for (int y = y0; y <= y1; ++y) {
            int x = s - y;
            int tile = mapData[y][x];
            if (tile < 0) continue;

            // izometrikus elhelyezés
            glm::vec2 pos;
            pos.x = offset.x + (x - y) * (tileWidth * 0.5f);
            pos.y = offset.y + (x + y) * (tileVisibleHeight * 0.5f);

            // atlasz UV
            float u0 = (tile * tileWidth) / (float)(tileWidth * tileCount);
            float u1 = ((tile + 1) * tileWidth) / (float)(tileWidth * tileCount);
            shader.SetVec4("uvRect", glm::vec4(u0, 0.0f, u1, 1.0f));

            glm::mat4 model(1.0f);
            model = glm::translate(model, glm::vec3(pos, 0.0f));
            shader.SetMat4("model", model);

            glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
        }
    }

    glBindVertexArray(0);
}